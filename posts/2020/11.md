---
title: Cybozu Frontend Monthly
date: "2020-11-24T17:00:00+09:00"
connpass:
streamUrl:
hashTag: "#サイボウズフロントエンドマンスリー"
no: 5
members:
  - name: "@koba04"
    link: https://twitter.com/koba04
  - name: "@pirosikick"
    link: https://twitter.com/pirosikick
  - name: "@toshi__toma"
    link: https://twitter.com/toshi__toma
  - name: "@zaki___yama"
    link: https://twitter.com/zaki___yama
  - name: "@__sakito__"
    link: https://twitter.com/__sakito__
  - name: "@shisama_"
    link: https://twitter.com/shisama_
  - name: "@nakajmg"
    link: https://twitter.com/nakajmg
  - name: "@b4h0_c4t"
    link: https://twitter.com/b4h0_c4t
  - name: "@__sosukesuzuki"
    link: https://twitter.com/__sosukesuzuki
guest:
---

### [Performance · microsoft/TypeScript Wiki](https://github.com/microsoft/TypeScript/wiki/Performance)

- 共有者:sakito

この wiki 自体は TypeScript チームがコンパイル速度や実装の体験をよくするための情報として、去年ごろに公開していました。

今年の秋ごろ[「Writing Easy-to-Compile Code」](https://github.com/microsoft/TypeScript/wiki/Performance#writing-easy-to-compile-code)の項目が追加されています。
この項目はコンパイルパフォーマンスがいい書き方を示してくれています。

項目は下記 3 つに別れています。

- [Preferring Interfaces Over Intersections](https://github.com/microsoft/TypeScript/wiki/Performance#writing-easy-to-compile-code)
  - Type を使った Intersection Types よりも interface の extends のほうがいいとのこと。
- [Using Type Annotations](https://github.com/microsoft/TypeScript/wiki/Performance#using-type-annotations)
  - 関数の戻り値の型は、明示的に型を定義したほうがコンパイル時間の節約になる。型推論は便利なので、コンパイルのボトルネックとなってる場合には試してねとのこと。
- [Preferring Base Types Over Unions](https://github.com/microsoft/TypeScript/wiki/Performance#using-type-annotations)
  - Union Type を使用するよりも sub types を使った方がよいとのこと(例のコードを見た方がわかりやすい)

interface と Type に関する記事は最近[「TypeScript: Prefer Interfaces」](https://ncjamieson.com/prefer-interfaces/)も出ており、
Type はインライン化されるので d.ts のサイズが肥大化するから interface を推奨するという内容の記事になっています。
これは d.ts を書く場合に覚えておくとよさそうです。

TypeScript の Type か interface を使うか、型推論に任せるかは時と場合によるというのを前提での紹介でした！

---

### [Vue Refの糖衣構文と Svelte](https://zenn.dev/kalan/articles/6e96e13fb2b0447af4f6)
- 共有者: nakajmg

vueのrfcに[`ref`](https://composition-api.vuejs.org/api.html#ref)の糖衣構文である[(Svelte inspiredな)`ref:`構文についてのrfc](https://github.com/vuejs/rfcs/blob/script-setup/active-rfcs/0000-script-setup.md#2-ref-sugar-makes-ref-usage-more-succinct)が出されました。この記事ではメリデメやSvelteとの比較などについて書かれています。

#### rfcの背景

vueではリアクティブな変数を定義するために`ref()`という関数を使います。

```js
import { createComponent, ref } from 'vue'

export default createComponent({
  setup() {
    const count = ref(1)

    function inc() {
      count.value++
    }

    console.log(count.value)

    return {
      count,
      inc
    }
  }
})
```

`ref()`で作成した変数の取得/更新は`count.value`のように`.value`を経由する必要があります。TypeScriptを採用していれば`.value`を経由しないで参照しようとするとエラーなりが出るので問題ないですが、そうでない場合は`ref()`で作られた変数と通常の(reactiveじゃない）変数を区別する必要があります。

#### 提案された構文

この`.value`を使うのが面倒で冗長だよねというところから次のような糖衣構文が提案されています。

```js
<script setup>
// declaring a variable that compiles to a ref
ref: count = 1

function inc() {
  // the variable can be used like a plain value
  count++
}

// access the raw ref object by prefixing with $
console.log($count.value)
</script>
```

> https://github.com/vuejs/rfcs/blob/script-setup/active-rfcs/0000-script-setup.md#2-ref-sugar-makes-ref-usage-more-succinct

[ラベル付き文](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/label)の構文を使ってreactiveな変数を定義し、`.value`なしに参照しています。

このコードはコンパイルされて👆にあるようなコードに変換されます。

#### JavaScriptのセマンティクスとトレードオフ

`.value`を経由するようになっているのはJavaScriptの言語的な制約からきているもので、vueはJavaScriptのセマンティクスを変更/拡張することなくリアクティブを実現するためにこうしています。
今回のrfcは、JavaScriptのセマンティクスから逸れてると認識しながらも、開発者の体験を向上させるためにトレードオフを行う余地があるのではという考えから提出されました。

#### 感想

自分は次の理由からあまりいい提案ではないように思います。

- vue独自の構文である
  - どんどん増えていきそう
  - JavaScriptエコシステムへの負荷(Linterとかエディタ）
- 本来のラベル付き文から逸脱している
- コンパイル前後のコードに差異が結構ある

この糖衣構文によって開発者の体験が短期的には向上するかもしれませんが、解決したい課題に対してデメリットが上回っていると感じています。（このrfcに限らずvueが`<script setup>`など、独自の糖衣構文的なものを追加してくる傾向があること自体にあまりいい印象を持っていないです。）

---
